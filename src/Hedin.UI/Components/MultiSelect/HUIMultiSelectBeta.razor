@namespace Hedin.UI
@typeparam T

<div class="@Class" style="@Style">
    <MudAutocomplete @ref="_autoComplete" T="T" @bind-Value="_value" SearchFunc="FilteredSearchFunc" MaxHeight="MaxHeight"
                     ShowProgressIndicator="true" DebounceInterval="250"
                     Label="@Label" Clearable="true"
                     Variant="Variant.Outlined" CoerceValue="true" Dense="Dense"
                     ToStringFunc="ToStringFunc" Margin="Margin.Dense"
                     ItemDisabledTemplate="ItemDisabledTemplate" ItemDisabledFunc="ItemDisabledFunc" Required="_required" MaxItems="null"
                     Disabled="Disabled" OpenIcon="@Icons.Material.Filled.Search" CloseIcon="@Icons.Material.Filled.Search">
        <BeforeItemsTemplate>
            @BeforeItemsTemplate
            @if (SelectAll)
            {
                <MudCheckBox T="bool" Label="@SelectAllText" Value="SelectAllValue" ValueChanged="HandleSelectAllClick"></MudCheckBox>
            }
        </BeforeItemsTemplate>
        <NoItemsTemplate>
            @NoItemsTemplate
            @if (SelectAll)
            {
                <MudCheckBox T="bool" Label="@SelectAllText" Value="SelectAllValue" ValueChanged="HandleSelectAllClick"></MudCheckBox>
            }
        </NoItemsTemplate>
        <ItemTemplate>
            <span class="d-flex align-center @ItemTemplateClass">
                <MudCheckBox Class="my-n3" T="bool" Value="selectedValues.Contains(context)" ValueChanged="(v) => HandleItemSelected(context)"></MudCheckBox>
                <span @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="()=>HandleItemSelected(context)">
                    @ItemTemplate.Invoke(context)
                </span>
            </span>
        </ItemTemplate>

    </MudAutocomplete>

    <MudChipSet AllClosable=true OnClose="RemoveValue" T="T" Color="Color" Variant="Variant.Outlined" CloseIcon="@Icons.Material.Filled.Close">
        @if (SelectAllValue)
        {
            <MudChip Size="Size.Small" Text="@AllItemsSelectedText" OnClick="() => HandleSelectAllClick(false)"></MudChip>
        }
        else
        {
            @foreach (var val in selectedValues)
            {
                string value = ChipToStringFunc(val);
                if (!string.IsNullOrWhiteSpace(value))
                {
                    <HUITooltip Text="@(ChipTooltipStringFunc != null ? ChipTooltipStringFunc(val) : "")" Style="max-width:250px;">
                        <MudChip Size=Size.Small Text="@value" Disabled="Disabled" />
                    </HUITooltip>
                }
            }
        }
    </MudChipSet>
</div>

@code {
    /// <summary>
    /// Collection of currently selected values.
    /// Bound to the component's selection state.
    /// </summary>
    [Parameter]
    public IEnumerable<T>? Values { get; set; }

    /// <summary>
    /// Event callback when the selection changes.
    /// Provides the updated collection of selected values.
    /// </summary>
    [Parameter]
    public EventCallback<IEnumerable<T>> ValuesChanged { get; set; }

    /// <summary>
    /// Label text displayed above the autocomplete input.
    /// Describes what the multi-select is for.
    /// </summary>
    [Parameter]
    public string Label { get; set; }

    /// <summary>
    /// Function that provides search results based on user input.
    /// Required for the autocomplete functionality to work.
    /// </summary>
    [Parameter, EditorRequired]
    public Func<string?, Task<IEnumerable<T>>> SearchFunc { get; set; }

    /// <summary>
    /// Function that converts items to display text in the dropdown.
    /// Required for proper item display in the autocomplete list.
    /// </summary>
    [Parameter, EditorRequired]
    public Func<T, string> ToStringFunc { get; set; }

    /// <summary>
    /// Function that converts selected items to text for chip display.
    /// Required for proper chip text rendering.
    /// </summary>
    [Parameter, EditorRequired]
    public Func<T, string> ChipToStringFunc { get; set; }

    /// <summary>
    /// Function that provides tooltip text for chips.
    /// Optional - when not provided, no tooltips are shown.
    /// </summary>
    [Parameter]
    public Func<T, string> ChipTooltipStringFunc { get; set; }

    /// <summary>
    /// Function that determines if an item should be disabled.
    /// Optional - when not provided, all items are enabled.
    /// </summary>
    [Parameter]
    public Func<T, bool> ItemDisabledFunc { get; set; }

    /// <summary>
    /// CSS class applied to the component container.
    /// Used for custom styling.
    /// </summary>
    [Parameter]
    public string Class { get; set; }

    /// <summary>
    /// CSS styles applied to the component container.
    /// Used for custom styling.
    /// </summary>
    [Parameter]
    public string Style { get; set; }

    /// <summary>
    /// CSS class applied to each item template.
    /// Used for consistent item styling.
    /// </summary>
    [Parameter]
    public string ItemTemplateClass { get; set; }

    /// <summary>
    /// Color theme for the chips and other UI elements.
    /// Affects the visual appearance of the component.
    /// </summary>
    [Parameter]
    public Color Color { get; set; }

    /// <summary>
    /// Makes the field required when true.
    /// Shows validation error when no items are selected.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }

    /// <summary>
    /// Template for rendering each item in the dropdown.
    /// Customizes the appearance of individual items.
    /// </summary>
    [Parameter]
    public RenderFragment<T> ItemTemplate { get; set; }

    /// <summary>
    /// Template for rendering disabled items.
    /// Customizes the appearance of disabled items.
    /// </summary>
    [Parameter]
    public RenderFragment<T> ItemDisabledTemplate { get; set; }

    /// <summary>
    /// Enables clearing the selection when true.
    /// Shows a clear button in the autocomplete input.
    /// </summary>
    [Parameter]
    public bool Clearable { get; set; }

    /// <summary>
    /// Disables the entire component when true.
    /// Prevents user interaction and shows disabled styling.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Enables the "Select All" functionality when true.
    /// Shows a checkbox to select/deselect all available items.
    /// </summary>
    [Parameter]
    public bool SelectAll { get; set; }

    /// <summary>
    /// Current state of the "Select All" checkbox.
    /// Bound to the select all functionality.
    /// </summary>
    [Parameter]
    public bool SelectAllValue { get; set; }

    /// <summary>
    /// Text displayed when all items are selected.
    /// Shown in a special chip when SelectAllValue is true.
    /// </summary>
    [Parameter]
    public string AllItemsSelectedText { get; set; } = "All items selected";

    /// <summary>
    /// Event callback when the "Select All" state changes.
    /// Provides the new select all value.
    /// </summary>
    [Parameter]
    public EventCallback<bool> SelectAllValueChanged { get; set; }

    /// <summary>
    /// Text displayed on the "Select All" checkbox.
    /// Describes the select all functionality.
    /// </summary>
    [Parameter]
    public String SelectAllText { get; set; }

    /// <summary>
    /// Content displayed before the items in the dropdown.
    /// Appears above the item list when the dropdown is open.
    /// </summary>
    [Parameter]
    public RenderFragment BeforeItemsTemplate { get; set; }

    /// <summary>
    /// Content displayed when no items are available.
    /// Customizes the empty state message.
    /// </summary>
    [Parameter]
    public RenderFragment NoItemsTemplate { get; set; }

    /// <summary>
    /// Reduces the spacing for a more compact appearance.
    /// Affects the overall component density.
    /// </summary>
    [Parameter]
    public bool Dense { get; set; } = true;

    /// <summary>
    /// Maximum height of the dropdown list.
    /// Prevents the dropdown from becoming too tall.
    /// </summary>
    [Parameter]
    public int MaxHeight { get; set; } = 300;

    private HashSet<T> selectedValues = new HashSet<T>();

    private MudAutocomplete<T>? _autoComplete;

    private bool _required => Required && (!selectedValues?.Any() ?? true);

    private async Task<IEnumerable<T>> FilteredSearchFunc(string searchText, CancellationToken token = default)
    {
        return await SearchFunc(searchText);
        // return results.Except(selectedValues);
    }

    // private IEnumerable<T> _allItems = [];
    // protected override async Task OnInitializedAsync()
    // {
    //     if((_allItems?.Count() ?? 0) > 1)
    //     {
    //         _allItems = await SearchFunc(null);
    //     }
    // }

    private void HandleItemSelected(T item)
    {
        if (selectedValues.Contains(item))
            selectedValues.Remove(item);
        else
            selectedValues.Add(item);
        RefreshBinding();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Values == null)
        {
            selectedValues.Clear();
        }
        else if (!Values.SequenceEqual(selectedValues))
        {
            selectedValues = Values.ToHashSet();
            ValuesChanged.InvokeAsync(Values);
        }
    }

    private void RefreshBinding()
    {
        Values = selectedValues.ToList();
        ValuesChanged.InvokeAsync(Values);
        StateHasChanged();
    }

    private void RemoveValue(MudChip<T> chip)
    {
        if (selectedValues.RemoveWhere(x => ChipToStringFunc(x) == chip.Text) > 0)
            RefreshBinding();
        if (SelectAllValue)
            HandleSelectAllClick(false);
    }

    private async Task AddValue(T newValue)
    {
        if (newValue != null)
        {
            if (selectedValues.Add(newValue))
                RefreshBinding();
        }

        var allItems = await SearchFunc(null);
        if (selectedValues.Count == allItems.Count())
        {
            await HandleSelectAllClick(true);
        }
    }

    // /// <summary>
    // /// Note that this is required to a) clear the control after you add
    // /// an item to the list, and b) to trigger the addvalue method.
    // /// If MudAutoComplete's bind-Value:after worked, we could get rid
    // /// of this and just clear the value after it was added.
    // /// </summary>
    private T _value
    {
        get => default(T);
        set { AddValue(value); }
    }

    public async Task Validate()
    {
        await _autoComplete!.Validate();
    }

    private async Task HandleSelectAllClick(bool value)
    {
        SelectAllValue = value;
        await SelectAllValueChanged.InvokeAsync(value);
        selectedValues.Clear();

        if (value)
        {
            var allItems = await SearchFunc(null);
            foreach (var item in allItems)
            {
                selectedValues.Add(item);
            }
        }
        SelectAll = value;
        RefreshBinding();
        await _autoComplete!.CloseMenuAsync();
        await _autoComplete!.Validate();
    }

    public async Task CloseMenuAsync()
    {
        await _autoComplete!.CloseMenuAsync();
    }
}